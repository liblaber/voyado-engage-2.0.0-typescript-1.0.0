// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse } from '../../http';
import { RequestConfig } from '../../http/types';
import {
  AddCheckpointToChallengeAssignmentResult,
  ChallengeAssignmentModel,
  ChallengeAssignmentModelsResult,
  ChallengeCheckPointDto,
  ChallengeDefinitionModel,
  ChallengeDefinitionModelsResult,
  addCheckpointToChallengeAssignmentResultResponse,
  challengeAssignmentModelResponse,
  challengeAssignmentModelsResultResponse,
  challengeCheckPointDtoRequest,
  challengeDefinitionModelResponse,
  challengeDefinitionModelsResultResponse,
} from '../common';
import {
  ChallengeConsentParams,
  ChallengeGetChallengeDefinitionsParams,
  ChallengeGetChallengesParams,
} from './request-params';

export class ChallengesService extends BaseService {
  /**
   * Get an challenge assignment by id.
   * @param {string} id - Assignment id
   * @returns {Promise<HttpResponse<ChallengeAssignmentModel>>} OK
   */
  async challengeGetChallengeById(
    id: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ChallengeAssignmentModel>> {
    const path = this.client.buildPath('/api/v2/challenges/{id}', { id: id });
    const options: any = {
      responseSchema: challengeAssignmentModelResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   * Get a challenge definition by id.
   * @param {string} id - Definition id
   * @returns {Promise<HttpResponse<ChallengeDefinitionModel>>} OK
   */
  async challengeGetChallengeDefinitionById(
    id: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ChallengeDefinitionModel>> {
    const path = this.client.buildPath('/api/v2/challenges/definitions/{id}', { id: id });
    const options: any = {
      responseSchema: challengeDefinitionModelResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   * Get a list of all the challenge definitions.
   * @param {number} [offset] - Defaults to 0
   * @param {number} [count] - Defaults to 100
   * @param {ChallengeGetChallengeDefinitionsStatus} [status] - All, Active, Draft or Ended. If not specified it will default to All
   * @returns {Promise<HttpResponse<ChallengeDefinitionModelsResult>>} OK
   */
  async challengeGetChallengeDefinitions(
    params?: ChallengeGetChallengeDefinitionsParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ChallengeDefinitionModelsResult>> {
    const path = '/api/v2/challenges/definitions';
    const options: any = {
      responseSchema: challengeDefinitionModelsResultResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.offset) {
      options.queryParams['offset'] = params?.offset;
    }
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    if (params?.status) {
      options.queryParams['status'] = params?.status;
    }
    return this.client.get(path, options);
  }

  /**
   * Search for challenges for a contact.
   * @param {string} contactId - Contact id
   * @param {string} [definitionId] - Definition id - Optional to limit to a certain challenge definition
   * @param {number} [offset] - Defaults to 0
   * @param {number} [count] - Defaults to 100
   * @param {ChallengeGetChallengesFilter} [filter] - All, Active, Completed or NotCompleted. If not specified it will default to All
   * @returns {Promise<HttpResponse<ChallengeAssignmentModelsResult>>} OK
   */
  async challengeGetChallenges(
    params: ChallengeGetChallengesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ChallengeAssignmentModelsResult>> {
    const path = '/api/v2/challenges';
    const options: any = {
      responseSchema: challengeAssignmentModelsResultResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactId) {
      options.queryParams['contactId'] = params?.contactId;
    }
    if (params?.definitionId) {
      options.queryParams['definitionId'] = params?.definitionId;
    }
    if (params?.offset) {
      options.queryParams['offset'] = params?.offset;
    }
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    if (params?.filter) {
      options.queryParams['filter'] = params?.filter;
    }
    return this.client.get(path, options);
  }

  /**
 * Send in a list of checkpoints to be assigned to a some challenge for a number of contacts,
the endpoint will able to take max 1000 checkpoint rows.
            
### The following fields should be provided:
            
- definitionId: Must be a Guid
- contactId: Must be a Guid
- checkPointAmount: Number of checkpoints to assign to the challenge
            
### Important info:
If some rows are not correct it will still result in an accepted response code and be skipped. Please
check the response for NotAccepted items
 * @returns {Promise<HttpResponse<AddCheckpointToChallengeAssignmentResult>>} OK
 */
  async challengeAddChallengeCheckPoints(
    body: ChallengeCheckPointDto[],
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<AddCheckpointToChallengeAssignmentResult>> {
    const path = '/api/v2/challenges/checkpoints';
    const options: any = {
      responseSchema: addCheckpointToChallengeAssignmentResultResponse,
      requestSchema: z.any(),
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
 * Will assign the challenge for the contact and return true. If the contact already
has been assigned for the challenge it will also return true.
 * @param {string} id - Definition id
 * @param {string} contactId - Contact id
 * @returns {Promise<HttpResponse<boolean>>} OK
 */
  async challengeConsent(
    id: string,
    params: ChallengeConsentParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<boolean>> {
    const path = this.client.buildPath('/api/v2/challenges/definitions/{id}/assign', { id: id });
    const options: any = {
      responseSchema: z.boolean(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactId) {
      options.queryParams['contactId'] = params?.contactId;
    }
    return this.client.post(path, options);
  }
}
