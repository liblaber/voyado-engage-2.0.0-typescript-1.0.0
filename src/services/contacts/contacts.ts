// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse } from '../../http';
import { RequestConfig } from '../../http/types';
import {
  ApiAdjustRewardPointsResponse1,
  ApiPromotionModel,
  BoolRequest,
  IApiContact,
  ListResultOfApiMessage,
  PagedResultOfApiMessage,
  PagedResultOfBonusPointTransactionModel,
  PagedResultOfTransactionItem,
  ProductRecommendationsModel,
  PurchaseHistorySummary,
  RedeemBodyModel,
  apiAdjustRewardPointsResponse1Response,
  apiPromotionModelResponse,
  boolRequestRequest,
  iApiContactResponse,
  listResultOfApiMessageResponse,
  pagedResultOfApiMessageResponse,
  pagedResultOfBonusPointTransactionModelResponse,
  pagedResultOfTransactionItemResponse,
  productRecommendationsModelResponse,
  purchaseHistorySummaryResponse,
  redeemBodyModelRequest,
} from '../common';
import {
  BonusPointTransactionsGetBonusPointTransactionsForContactParams,
  ContactBulkCreateContactsInBulkParams,
  ContactBulkGetBulkStatusParams,
  ContactBulkUpdateContactsInBulkParams,
  ContactMessageEmailUnsubscribeContactParams,
  ContactMessageGetLatestMessagesByContactIdParams,
  ContactMessageGetMessagesByContactIdParams,
  ContactMessageSmsUnsubscribeContactParams,
  ContactOverviewGetContactIdAsyncParams,
  ContactsVCreateContactHeaderParamParams,
  ContactsVDeleteWithHeaderParamParams,
  ContactsVGetChangedContactIdsParams,
  ContactsVGetContactByTypeAndKeyValueAsyncParams,
  ContactsVPromoteToMemberParams,
  ContactsVUpdateContactTypeParams,
  OfferPromotionsGetPromotionsForContactParams,
  TransactionsGetTransactionsByContactIdParams,
} from './request-params';
import { ApiAdjustRewardPoints, apiAdjustRewardPointsRequest } from './models';

export class ContactsService extends BaseService {
  /**
 * Get number of approved contacts. 

This is a cached value that will be updated with a 
set frequency (normally once every 20 min).
 * @returns {Promise<HttpResponse<number>>} OK
 */
  async contactsVCount(requestConfig?: RequestConfig): Promise<HttpResponse<number>> {
    const path = '/api/v2/contacts/count';
    const options: any = {
      responseSchema: z.number(),
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
 * Get a single contact, using the unique identifier.

The dynamic fields of the response object depend on
the current instance configuration.
 * @param {string} contactId - Contact identifier (GUID).
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactsVGetContactById(contactId: string, requestConfig?: RequestConfig): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}', { contactId: contactId });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
 * Update one or several fields of a single contact.
Dont send an empty value unless you want it to be empty.
 * @param {string} contactId - Contact identifier (GUID).
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactsVUpdateContactPost(
    contactId: string,
    body: any,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}', { contactId: contactId });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
   *
   * @param {string} contactId - Contact identifier (GUID).
   * @param {string} [source] - Source system identifier (instance configuration)
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async contactsVDeleteWithHeaderParam(
    contactId: string,
    params?: ContactsVDeleteWithHeaderParamParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}', { contactId: contactId });
    const options: any = {
      responseSchema: z.any(),
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.source) {
      options.headers['source'] = params?.source;
    }
    return this.client.delete(path, options);
  }

  /**
 * Get number of approved contacts of given type. 

This is a cached value that will be updated with a 
set frequency (normally once every 20 min).
 * @param {string} contactType - Id for contact type, e.g. "member" or "contact"
 * @returns {Promise<HttpResponse<number>>} OK
 */
  async contactsVCountByContactType(contactType: string, requestConfig?: RequestConfig): Promise<HttpResponse<number>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactType}/count', { contactType: contactType });
    const options: any = {
      responseSchema: z.number(),
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   *
   * @param {string} batchId - Id from bulk contact import
   * @returns {Promise<HttpResponse<any>>} Status object for batch
   */
  async contactBulkGetBulkStatus(
    params: ContactBulkGetBulkStatusParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = '/api/v2/contacts/bulk/status';
    const options: any = {
      responseSchema: z.any(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.batchId) {
      options.queryParams['batchId'] = params?.batchId;
    }
    return this.client.get(path, options);
  }

  /**
 * ! Please be aware that this endpoint is currently usable with either the key value being provided through !
! the path or a query param. Hence there being two of the same endpoints. !
! We recommend that you use the query param version (the first) as it is the more versatile one of the two !

Get a single contact of a certain type, using a key
value that corresponds to the current instance configuration. This can
only be used for contact types with exactly ONE key.

The dynamic fields of the response object depend on
the current configuration.
 * @param {string} contactType - Contact type, e.g. "member".
 * @param {string} keyValue - Key value, e.g. ssn, phone number etc.
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactsVGetContactByTypeAndKeyValueInUrlAsync(
    contactType: string,
    keyValue: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactType}/bykey/{keyValue}', {
      contactType: contactType,
      keyValue: keyValue,
    });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   *
   * @param {string} contactId - Contact identifier (GUID).
   * @returns {Promise<HttpResponse<ProductRecommendationsModel>>} OK
   */
  async productRecommendationGetProductRecommendations(
    contactId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ProductRecommendationsModel>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/productrecommendations', { contactId: contactId });
    const options: any = {
      responseSchema: productRecommendationsModelResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   * Following summary shows the purchase history for a single contact, over all time, 12 months and 24 months.
   * @param {string} contactId - Contact identifier (GUID)
   * @returns {Promise<HttpResponse<PurchaseHistorySummary>>} OK
   */
  async contactRetailKpiGetPurchaseHistory(
    contactId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<PurchaseHistorySummary>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/purchasehistorysummary', { contactId: contactId });
    const options: any = {
      responseSchema: purchaseHistorySummaryResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
   * Get back in stock subscriptions for a contact
   * @param {string} contactId -
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async backInStockSubscriptionGetByContactId(
    contactId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<undefined>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/backinstock/subscriptions', {
      contactId: contactId,
    });
    const options: any = {
      responseSchema: z.undefined(),
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
 * Get a single contact of a certain type, using the
contact's external id.

The dynamic fields of the response object depend on
the current configuration.
 * @param {string} contactType - Contact type, e.g. Member or Contact.
 * @param {string} externalId - External contact id.
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactsVGetContactByExternalIdAsync(
    contactType: string,
    externalId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactType}/byexternalid/{externalId}', {
      contactType: contactType,
      externalId: externalId,
    });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.get(path, options);
  }

  /**
 * Get a single contact of a certain type, using a key
value that corresponds to the current instance configuration. This can
only be used for contact types with exactly ONE key.

The dynamic fields of the response object depend on
the current configuration.
 * @param {string} contactType - Contact type, e.g. "member".
 * @param {string} keyValue - Key value, e.g. ssn, phone number etc.
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactsVGetContactByTypeAndKeyValueAsync(
    contactType: string,
    params: ContactsVGetContactByTypeAndKeyValueAsyncParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactType}/bykey', { contactType: contactType });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.keyValue) {
      options.queryParams['keyValue'] = params?.keyValue;
    }
    return this.client.get(path, options);
  }

  /**
   * Get the latest messages (max 500) a contact has received
   * @param {string} contactId - Contact identifier (GUID).
   * @param {number} [count] - Max number of items to take. (Default value 100, Max value 500)
   * @returns {Promise<HttpResponse<ListResultOfApiMessage>>} OK
   */
  async contactMessageGetLatestMessagesByContactId(
    contactId: string,
    params?: ContactMessageGetLatestMessagesByContactIdParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ListResultOfApiMessage>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/messages/latest', { contactId: contactId });
    const options: any = {
      responseSchema: listResultOfApiMessageResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    return this.client.get(path, options);
  }

  /**
   * Optional offset and number of messages in response.
   * @param {string} contactId - Contact identifier (GUID).
   * @param {number} [offset] - Default value 0
   * @param {number} [count] - Max number of items to take. (Default value 100, max 500)
   * @returns {Promise<HttpResponse<PagedResultOfApiMessage>>} OK
   */
  async contactMessageGetMessagesByContactId(
    contactId: string,
    params?: ContactMessageGetMessagesByContactIdParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<PagedResultOfApiMessage>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/messages', { contactId: contactId });
    const options: any = {
      responseSchema: pagedResultOfApiMessageResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.offset) {
      options.queryParams['offset'] = params?.offset;
    }
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    return this.client.get(path, options);
  }

  /**
 * Get all purchase transactions for a single contact with 
optional offset and number of transactions in response.
 * @param {string} contactId - Contact identifier (GUID)
 * @param {number} [offset] - Number of items to skip. (Default value 0)
 * @param {number} [count] - Max number of items to take. (Default value 100)
 * @returns {Promise<HttpResponse<PagedResultOfTransactionItem>>} OK
 */
  async transactionsGetTransactionsByContactId(
    contactId: string,
    params?: TransactionsGetTransactionsByContactIdParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<PagedResultOfTransactionItem>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/transactions', { contactId: contactId });
    const options: any = {
      responseSchema: pagedResultOfTransactionItemResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.offset) {
      options.queryParams['offset'] = params?.offset;
    }
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    return this.client.get(path, options);
  }

  /**
   *
   * @param {string} contactId - The contact identifier (GUID).
   * @param {number} [offset] - The first item to retrieve. (Default value 0)
   * @param {number} [count] - The max number of items to retrieve. (Default value 100)
   * @returns {Promise<HttpResponse<PagedResultOfBonusPointTransactionModel>>} OK
   */
  async bonusPointTransactionsGetBonusPointTransactionsForContact(
    contactId: string,
    params?: BonusPointTransactionsGetBonusPointTransactionsForContactParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<PagedResultOfBonusPointTransactionModel>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/bonuspointtransactions', { contactId: contactId });
    const options: any = {
      responseSchema: pagedResultOfBonusPointTransactionModelResponse,
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.offset) {
      options.queryParams['offset'] = params?.offset;
    }
    if (params?.count) {
      options.queryParams['count'] = params?.count;
    }
    return this.client.get(path, options);
  }

  /**
   *
   * @param {ChangeType} changeType - Created, Updated or Deleted
   * @param {string} fromDate - Start of timespan (ex 2023-05-04 11:20:00.000)
   * @param {string} [toDate] - End of timespan (Default the current time and date)
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async contactsVGetChangedContactIds(
    params: ContactsVGetChangedContactIdsParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = '/api/v2/contacts/changes';
    const options: any = {
      responseSchema: z.any(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.changeType) {
      options.queryParams['changeType'] = params?.changeType;
    }
    if (params?.fromDate) {
      options.queryParams['fromDate'] = params?.fromDate;
    }
    if (params?.toDate) {
      options.queryParams['toDate'] = params?.toDate;
    }
    return this.client.get(path, options);
  }

  /**
 * Get available promotions for a contact. To filter on redemptionChannelType add it as a query string
?redemptionChannelType=POS
It can be POS, ECOM or OTHER
 * @param {string} contactId - Contact identifier
 * @param {string} [redemptionChannelType] - Filter on redemptionChannelType it can be POS, ECOM or OTHER
 * @returns {Promise<HttpResponse<ApiPromotionModel[]>>} OK
 */
  async offerPromotionsGetPromotionsForContact(
    contactId: string,
    params?: OfferPromotionsGetPromotionsForContactParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ApiPromotionModel[]>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/promotions', { contactId: contactId });
    const options: any = {
      responseSchema: z.array(apiPromotionModelResponse),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.redemptionChannelType) {
      options.queryParams['redemptionChannelType'] = params?.redemptionChannelType;
    }
    return this.client.get(path, options);
  }

  /**
 * Get the contactId for one (or several) contacts using either:
- email
- socialSecurityNumber
- mobilePhone
- customKey (the customKey must be configured by your supplier)
- any - the any field can contain email, socialSecurityNumber, mobilePhone or the custom key (and are checked in that order)
 * @param {string} [contactType] - 
 * @param {string} [email] - 
 * @param {string} [socialSecurityNumber] - 
 * @param {string} [mobilePhone] - 
 * @param {string} [customKey] - 
 * @param {string} [any_] - 
 * @returns {Promise<HttpResponse<string>>} OK
 */
  async contactOverviewGetContactIdAsync(
    params?: ContactOverviewGetContactIdAsyncParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<string>> {
    const path = '/api/v2/contacts/id';
    const options: any = {
      responseSchema: z.string(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactType) {
      options.queryParams['contactType'] = params?.contactType;
    }
    if (params?.email) {
      options.queryParams['email'] = params?.email;
    }
    if (params?.socialSecurityNumber) {
      options.queryParams['socialSecurityNumber'] = params?.socialSecurityNumber;
    }
    if (params?.mobilePhone) {
      options.queryParams['mobilePhone'] = params?.mobilePhone;
    }
    if (params?.customKey) {
      options.queryParams['customKey'] = params?.customKey;
    }
    if (params?.any_) {
      options.queryParams['any'] = params?.any_;
    }
    return this.client.get(path, options);
  }

  /**
 * Create a new, approved contact.

If the contacts key identifier (example: Email) already exists : returns the GUID of the first entry found.
 * @param {string} [source] - Source system identifier (instance configuration)
 * @param {string} [storeExternalId] - The unique id code of the current store (and therefore also the recruited-by store). Not mandatory but strongly recommended.
 * @param {string} [createAsUnapproved] - Contact is not approved on creation. (Default value false)
 * @returns {Promise<HttpResponse<IApiContact>>} Created
 */
  async contactsVCreateContactHeaderParam(
    body: any,
    params?: ContactsVCreateContactHeaderParamParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = '/api/v2/contacts';
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.source) {
      options.headers['source'] = params?.source;
    }
    if (params?.storeExternalId) {
      options.headers['storeExternalId'] = params?.storeExternalId;
    }
    if (params?.createAsUnapproved) {
      options.headers['createAsUnapproved'] = params?.createAsUnapproved;
    }
    return this.client.post(path, options);
  }

  /**
   * Promote a contact to a member with one or several required fields.
   * @param {string} contactId - Contact identifier (GUID).
   * @param {string} [source] - Source system identifier (instance configuration)
   * @returns {Promise<HttpResponse<IApiContact>>} OK
   */
  async contactsVPromoteToMember(
    contactId: string,
    body: any,
    params?: ContactsVPromoteToMemberParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/promoteToMember', { contactId: contactId });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: z.any(),
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.source) {
      options.headers['source'] = params?.source;
    }
    return this.client.post(path, options);
  }

  /**
   *
   * @param {string} [contactType] - Optional, if not set the default ContactType will be used
   * @returns {Promise<HttpResponse<string>>} BatchId
   */
  async contactBulkCreateContactsInBulk(
    body: any,
    params?: ContactBulkCreateContactsInBulkParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<string>> {
    const path = '/api/v2/contacts/bulk';
    const options: any = {
      responseSchema: z.string(),
      requestSchema: z.any(),
      body: body as any,
      queryParams: {},
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactType) {
      options.queryParams['contactType'] = params?.contactType;
    }
    return this.client.post(path, options);
  }

  /**
   *
   * @param {string} [contactType] - Optional, if not set the default ContactType will be used
   * @param {boolean} [avoidTriggeringExport] - Optional, default value is false
   * @returns {Promise<HttpResponse<string>>} BatchId
   */
  async contactBulkUpdateContactsInBulk(
    body: any,
    params?: ContactBulkUpdateContactsInBulkParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<string>> {
    const path = '/api/v2/contacts/bulk';
    const options: any = {
      responseSchema: z.string(),
      requestSchema: z.any(),
      body: body as any,
      queryParams: {},
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactType) {
      options.queryParams['contactType'] = params?.contactType;
    }
    if (params?.avoidTriggeringExport) {
      options.queryParams['avoidTriggeringExport'] = params?.avoidTriggeringExport;
    }
    return this.client.patch(path, options);
  }

  /**
 * Update the preference that indicates whether or not
a contact accepts to be contacted via sms. This will also approve an unapproved contact.
The primary way of updating a contact preference is through the update contacts endpoint.
 * @param {string} contactId - Contact identifier (GUID).
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactPreferencesAcceptsSms(
    contactId: string,
    body: BoolRequest,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/preferences/acceptsSms', { contactId: contactId });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: boolRequestRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
   * Adds reward points to a contact.
   * @param {string} contactId - Contact identifier (GUID).
   * @returns {Promise<HttpResponse<ApiAdjustRewardPointsResponse1>>} OK
   */
  async bonusPointTransactionsAdjustRewardPoints(
    contactId: string,
    body: ApiAdjustRewardPoints,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ApiAdjustRewardPointsResponse1>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/rewardpointtransaction', { contactId: contactId });
    const options: any = {
      responseSchema: apiAdjustRewardPointsResponse1Response,
      requestSchema: apiAdjustRewardPointsRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
 * Update the preference that indicates whether or not 
a contact accepts to be contacted via email. This will also approve an unapproved contact.
The primary way of updating a contact preference is through the update contacts endpoint.
 * @param {string} contactId - Contact identifier (GUID).
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactPreferencesAcceptsEmail(
    contactId: string,
    body: BoolRequest,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/preferences/acceptsEmail', {
      contactId: contactId,
    });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: boolRequestRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
 * Update the preference that indicates whether or not
a contact accepts to be contacted via regular mail. This will also approve an unapproved contact.
The primary way of updating a contact preference is through the update contacts endpoint.
 * @param {string} contactId - Contact identifier (GUID).
 * @returns {Promise<HttpResponse<IApiContact>>} OK
 */
  async contactPreferencesAcceptsPostal(
    contactId: string,
    body: BoolRequest,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<IApiContact>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/preferences/acceptsPostal', {
      contactId: contactId,
    });
    const options: any = {
      responseSchema: iApiContactResponse,
      requestSchema: boolRequestRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
 * Assign a promotion (multichannel offer only) to a Contact using the internal Contact Id
and the id of the promotion
 * @param {string} contactId - Contact identifier
 * @param {string} promotionId - The id of the promotion
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async assignPromotionAssign(
    contactId: string,
    promotionId: string,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/promotions/{promotionId}/assign', {
      contactId: contactId,
      promotionId: promotionId,
    });
    const options: any = {
      responseSchema: z.any(),
      requestSchema: z.any(),
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
 * Redeem a promotion (multichannel offer or mobile swipe) for a Contact using the internal Contact Id

Redemption channel can be POS, ECOM or OTHER.
 * @param {string} contactId - Contact identifier
 * @param {string} promotionId - The id of the promotion
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async offerPromotionsRedeem(
    contactId: string,
    promotionId: string,
    body: RedeemBodyModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/promotions/{promotionId}/redeem', {
      contactId: contactId,
      promotionId: promotionId,
    });
    const options: any = {
      responseSchema: z.any(),
      requestSchema: redeemBodyModelRequest,
      body: body as any,
      headers: {
        'Content-Type': 'application/json',
      },
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    return this.client.post(path, options);
  }

  /**
   * Optional messageId input if user wants to unsubscribe on specific message instead of last sent Sms
   * @param {string} contactId - Contact identifier (GUID).
   * @param {string} [messageId] - Message Id (string).
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async contactMessageSmsUnsubscribeContact(
    contactId: string,
    params?: ContactMessageSmsUnsubscribeContactParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/unsubscribeSms', { contactId: contactId });
    const options: any = {
      responseSchema: z.any(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.messageId) {
      options.queryParams['messageId'] = params?.messageId;
    }
    return this.client.post(path, options);
  }

  /**
   * Optional messageId input if user wants to unsubscribe on specific message instead of last sent email
   * @param {string} contactId - Contact identifier (GUID).
   * @param {string} [messageId] - Message Id (string).
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async contactMessageEmailUnsubscribeContact(
    contactId: string,
    params?: ContactMessageEmailUnsubscribeContactParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<undefined>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/unsubscribeEmail', { contactId: contactId });
    const options: any = {
      responseSchema: z.undefined(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.messageId) {
      options.queryParams['messageId'] = params?.messageId;
    }
    return this.client.post(path, options);
  }

  /**
   * Updates the contactType for a contact if all expected contact data is available
   * @param {string} contactId - Contact identifier (GUID).
   * @param {string} contactTypeId - The ContactType id (string).
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async contactsVUpdateContactType(
    contactId: string,
    params: ContactsVUpdateContactTypeParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<undefined>> {
    const path = this.client.buildPath('/api/v2/contacts/{contactId}/updateContactType', { contactId: contactId });
    const options: any = {
      responseSchema: z.undefined(),
      requestSchema: z.any(),
      queryParams: {},
      headers: {},
      requestContentType: ContentType.Json,
      responseContentType: ContentType.Json,
      retry: requestConfig?.retry,
      config: this.config,
    };
    if (params?.contactTypeId) {
      options.queryParams['contactTypeId'] = params?.contactTypeId;
    }
    return this.client.post(path, options);
  }
}
